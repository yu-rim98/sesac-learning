## 다형성(Polymorphism)이란?
> 하나의 타입(부모)으로 여러 형태(자식)를 다루는 것을 의미한다.

즉, 부모 클래스의 참조 변수로 여러 자식 클래스 객체를 **같은 타입으로 다루는 것**이다.

```java
Animal3 a1 = new Dog3();
Animal3 a2 = new Cat3();
Animal3 a3 = new Bird3();
```
`a1`, `a2`, `a3` 모두 `Animal3` 타입이지만 실제로는 각각 **Dog3, Cat3, Bird3 객체를 가리킨다.**


## 다형성의 작동 원리
### 참조 변수의 타입이 무엇이냐 -> 접근 가능한 멤버의 범위를 결정한다.
* 컴파일 시점에 결정된다.

### 실제 객체의 타입이 무엇이냐 -> 실행될 메서드의 내용을 결정한다.
* 실행 시점에 결정된다.


| 구분               | 결정 시점  | 예시                                  |
| ---------------- | ------ | ----------------------------------- |
| 사용할 수 있는 메서드의 목록 | 컴파일 시점 | `a1.makeSound()` 가능, `a1.hi()` 불가능  |
| 실제 실행되는 메서드      | 실행 시점  | `a1.makeSound()` -> Dog3의 "멍멍"  실행됨 |

---
## 왜 참조 변수를 부모 타입으로 선언하나?
### 1. 코드의 일관성, 확장성 확보를 위해
```java
Animal3[] animals = {
	new Dog3(),
	new Cat3(),
	new Bird3()
};

for (Animal3 a : animals) {
	a.makeSound(); // 각 클래스에 맞는 소리가 출력
}
```
* 새로운 동물 클래스를 추가해도 `for`문이나 메서드 로직은 **수정할 필요가 없다.**
* 즉, **공통 인터페이스(부모 타입)로 묶을 수 있어야 유연한 코드가 된다.**

### 2. 중복 코드 제거 & 유지보수 용이

```java
Dog3 d = new Dog3();
Cat3 c = new Cat3();
Bird3 b = new Bird3();

d.makeSound();
c.makeSound();
b.makeSound();
```
* 다형성을 사용하지 않는 경우
    * 클래스가 추가될 때마다 중복 코드를 추가해야 한다.

---
## 바인딩
|구분|바인딩 시점|대상|특징|
|---|---|---|---|
|**정적 바인딩 (Static Binding)**|컴파일 시점|static, private, final 메서드, 필드|참조 변수 타입 기준|
|**동적 바인딩 (Dynamic Binding)**|실행 시점|오버라이딩된 인스턴스 메서드|실제 객체 타입 기준|
참조 변수의 타입은 접근 범위를 결정하고, 실제 객체 타입은 실행될 메서드를 결정한다.