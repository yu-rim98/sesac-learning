# JPA 핵심 정리
## 1. 엔티티와 영속성 컨텍스트
* JPA의 가장 기본이 되는 개념은 **객체와 관계형 데이터베이스(RDB) 간의 매핑**과 이를 관리하는 **영속성 컨텍스트**이다.

### 1.1 기본 개념
* 엔티티(Entity) : JPA가 관리하는 자바 객체로 DB 테이블의 한 행(Row)에 해당한다.
* 영속성 컨텍스트(Persistence Context) : 엔티티를 영구 저장하는 논리적인 환경이다.
    * `EntityManager`를 통해 접근하며 눈에 보이지 않는 **엔티티 저장소** 역할을 한다.

### 1.2 엔티티의 생명주기(Lifecycle)
* 엔티티는 영속성 컨텍스트와의 관계에 따라 4가지 상태를 가진다.
    1. 비영속 : 객체만 생성하고 영속성 컨텍스트와는 전혀 관계없는 상태
    2. 영속 : 영속성 컨텍스트에 저장되어 관리되는 상태(`em.persist()`)
        * 특징 : 1차 캐시, 더티 체킹, 쓰기 지연 등이 제공됨
    3. 준영속 :영속성 컨텍스트에 저장되었다가 분리된 상태(`em.detach()`)
    4. 삭제 : 삭제된 상태(`em.remove()`)

### 1.3 영속성 컨텍스트의 핵심 기능 3가지
1. 1차 캐시
    * 구조 : `Map<Key(@Id), Value(Entity)>` 형태의 메모리 저장소
    * 동작 : `findById()` 호출 시 DB보다 먼저 1차 캐시를 조회한다.
        * 있으면 : 메모리에서 바로 반환(SQL 실행 X)
        * 없으면 : DB조회 -> 1차 캐시 저장 -> 반환
    * 이점 : 동일 트랜잭션 내에서 **반복 조회 시 성능 향상** 및 객체 동일성(`==`)이 보장된다.

2. 쓰기 지연
    * 개념 : `persist()`나 `update` 발생 시 즉시 SQL을 보내지 않고 **쓰기 지연 SQL 저장소**에 모아둔다.
    * 동작 : 트랜잭션을 `commit()`하는 순간(또는 `flush()` 호출 시) 모아둔 쿼리를 한번에 DB로 전송한다.
    * 이점 : 네트워크 통신 비용을 줄이는 배치 처리 효과를 볼 수 있다.

3. 변경 감지
    * 개념 : 개발자가 `update()` 메서드를 호출하지 않아도 데이터 변경을 감지해 자동으로 `UPDATE` 쿼리를 날린다.
    * 원리 :
        1. 엔티티를 처음 조회할 때의 상태를 **스냅샷**으로 저장해둔다.
        2. `flush` 시점에 **엔티티(현재 값)와 스냅샷(과거 값)**을 비교한다.
        3. 변경 사항이 있으면 `UPDATE` SQL을 생성해 쓰기 지연 저장소에 등록한다.

---
## 2. 영속성 컨텍스트와 트랜잭션의 관계
* 스프링 컨테이너 환경에서 JPA는 **데이터의 안전성과 격리성**을 위해 독특한 방식으로 동작한다.

### 2.1 동작 메커니즘
* 생성 : 트랜잭션이 시작될 때 영속성 컨텍스트가 생성된다.
* 격리 : 생성된 컨텍스트는 ThreadLocal에 바인딩되어 해당 스레드(요청)에서만 접근 가능하다. 따라서 멀티 스레드 환경에서도 다른 사용자의 요청과 섞이지 않는다.
* 종료 : 트랜잭션이 커밋되고 종료되면 영속성 컨텍스트도 함께 소멸한다.

### 2.2 플러시(Flush)와 커밋(Commit)
* 플러시(Flush) : 영속성 컨텍스트의 변경 내용(SQL)을 DB에 **전송(동기화)**하는 작업이다.
    * 트랜잭션이 끝난 건 아님
* 커밋(Commit) : DB에 반영된 데이터를 **영구 확정**하는 작업이다.
    * 커밋 시 자동으로 플러시가 먼저 일어남

---
## 3. 프록시(Proxy)와 지연 로딩
* JPA 성능 최적화의 핵심 기술인 지연 로딩을 구현하기 위해 사용하는 **가짜 객체**이다.

### 3.1 프록시 종류

| 구분    | EntityManager 프록시                                      | Entity 프록시              |
| ----- | ------------------------------------------------------ | ----------------------- |
| 생성 주체 | 스프링 프레임워크                                              | JPA 구현체(Hibernate)      |
| 목적    | 스레드 안전성 보장(여러 스레드가 공유하는 Repository에서 ThreadLocal로 라우팅) | 지연 로딩 구현 (불필요한 조인 방지)   |
| 역할    | 현재 스레드의 영속성 컨텍스트를 찾아 작업을 위임                            | 실제 데이터 접근 시점에 DB 조회를 수행 |

### 3.2 지연 로딩 동작 원리
1. 가짜 객체 주입 : `Team`을 조회할 때 연관된 `Member`는 DB에서 가져오지 않고, `Member`를 상속받은 **프록시 객체**를 넣어둔다.(내부 `target`은 `null`)
2. 초기화 트리거 : `member.getName()`처럼 실제 값을 사용하는 메서드를 호출할 때 초기화가 일어난다.
3. 초기화 과정 : 프록시 -> 영속성 컨텍스트에 요청 -> DB 조회 -> 실제 엔티티 생성 -> 프록시의 `target` 에 연결 -> 값 반환

* `getId()`는 프록시 상태에서도 반환될 수 있음

---
## 4. 다양한 쿼리 방법과 페이징
### 4.1 쿼리 전략 비교

| 방식           | 설명                                   | 장점                     | 단점                          |
| ------------ | ------------------------------------ | ---------------------- | --------------------------- |
| 쿼리 메서드       | `findByTitle(String title)`          | 작성 편리, 직관적             | 조건이 많아지면 메서드명이 너무 길어진다.     |
| JPQL         | `@Query("select m from Member m ...` | 복잡한 쿼리 가능, DB 독립적      | 문자열이라 컴파일 시점에 오류를 발견할 수 없다. |
| Native Query | `nativeQuery = true`                 | 특정 DB 전용 기능/SQL 사용 가능  | DB 종속적, 유지보수 어려움            |
| QueryDSL     | 자바 코드로 쿼리 작성                         | 컴파일 타임 오류 체크, 동적 쿼리 용이 | 초기 설정이 번거롭다.                |

### 4.2 페이징(Page vs Slice)
* Page(`Page<T>`) : 데이터(`content`) + 총 페이지 수, 전체 개수(`totalElements`)를 포함한다.
    * **Count 쿼리가 필수적으로 추가 실행된다.**
* Slice(`Slice<T>`) : 전체 개수 대신 **다음 페이지가 있는지(`hasNext`)만** 확인한다.
    * **`Limit + 1` 조회 방식을 사용해 Count 쿼리가 나가지 않아 성능상 유리하다.**

---
## 5. N+1 문제와 해결
* JPA를 사용할 때 가장 빈번하게 발생하는 성능 문제이다.

### 5.1 문제 발생 원인
* 1+N : 최초 쿼리 1번(`select * from Team`)으로 N개의 결과를 가져왔는데 각 결과를 순회하며 연관된 데이터(`Member`)를 조회하기 위해 추가 쿼리가 N번 발생하는 현상이다.
* 주로 지연 로딩된 프록시를 반복문 안에서 초기화할 때 발생한다.

### 5.2 해결 방법
1. 패치 조인(Fetch Join)
```java
@Query("select p from Post p join fetch p.comments")
List<Post> findAllJoinFetch();
```
* 원리 : JPQL 실행 시점에 연관된 데이터를 한번의 쿼리(`INNER JOIN`)로 가져와 영속성 컨텍스트에 모두 채운다.
* 주의 : 페이징 쿼리에 사용하면 메모리 이슈 발생할 수 있고, 2개 이상의 컬렉션은 패치 조인이 불가하다.

2. Batch Size (`default_batch_fetch_size`)
```yaml
spring.jpa.properties.hibernate.default_batch_fetch_size: 100
```
* 원리 : 지연 로딩 시 1개씩 조회하는게 아니라 설정한 사이즈만큼 `IN`절로 묶어서 조회한다.
* 효과 : N+1 문제를 1+1 문제로 최적화한다. 컬렉션 페이징 문제를 해결할 수 있다.

3. EntityGraph
* JPQL 없이 어노테이션(`@EntityGraph`)으로 패치 조인 효과를 낼 수 있다.
* `LEFT OUTER JOIN`을 사용한다.

---
## 6. JPA 내부 동작과 리플렉션
* JPA가 `setter` 없이 `private` 필드에도 값을 채울 수 있는 이유

### 6.1 동작 원리
* JPA(Hibernate)는 자바 리플렉션(Reflection) API를 기반으로 동작한다.
1. `Class.getDeclaredField()` 등을 사용해 메타데이터 정보를 가져온다.
2. `setAccessible(true)`를 통해 `private` 필드에 접근할 수 있도록 설정한다.
3. 필드에 직접 값을 주입한다.

### 6.2 기본 생성자가 필요한 이유
* 위 과정에서 리플렉션으로 객체를 생성(`Class.newInstance()`)해야 하기 때문에 JPA 엔티티는 **반드시 인자가 없는 기본 생성자(`protected` 이상)** 가 필요하다.

### 6.3 성능 최적화
* 순수 리플렉션은 느리기 때문에 Hibernate는 바이트코드 조작(CGLIB, ByteBuddy 등)을 통해 런타임에 **최적화된 접근 클래스**를 생성하거나 `Unsafe`, `MethodHandle` 등을 사용해 성능 저하를 최소화한다.
