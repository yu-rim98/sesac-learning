# 1. 프로젝트 개요 및 구조
## 1. 프로젝트 목표
* 간단한 콘솔 기반의 온라인 상점을 시뮬레이션 하면서 **객체의 역할과 책임을 분리**하고, **객체 간의 협력**을 통해 하나의 프로그램을 만드는 과정을 학습합니다.

## 2. 프로젝트 구조 (`src` 디렉토리 기준)
```java
com.shop
├── ShopApp.java              # 프로그램의 시작 및 전체 시나리오 담당
├── manager
│   └── ShopManager.java      # 상품 및 주문을 총괄 관리하는 매니저
├── model
│   ├── Product.java          # 상품의 정보(데이터)를 담는 객체
│   └── Order.java            # 주문 정보(데이터)를 담는 객체
└── utils
    └── IdGenerator.java      # 고유 ID를 생성하는 유틸리티
```

# 2. 클래스별 역할과 책임
* 각 클래스에 명확한 역할과 책임을 부여하는 것이 좋은 객체 지향 설계이다.

| 클래스           | 핵심역할       | 주요 책임                                                                                              |
| ------------- | ---------- | -------------------------------------------------------------------------------------------------- |
| `ShopApp`     | Client     | - 프로그램의 시작점(`main`)으로 전체 시나리오 (상품 등록 -> 조회 -> 주문)를 순서대로 실행한다.                                      |
| `ShopManager` | Controller | - `Product`와 `Order` 객체 목록을 배열로 관리하며 상품 등록, 검색, 재고 관리, 주문 생성, 주문 항목 추가, 최종 결제 처리를 한다.              |
| `Product`     | Model      | - 상품의 속성(ID, 이름, 가격, 재고)을 저장하고, 자기 데이터는 스스로 관리한다. (`decreaseStock`, `isAvailable`)                 |
| `Order`       | Model      | - 주문의 속성(ID, 상품 목록, 수량, 총액, 상태)을 저장하고, 주문과 관련된 계산 및 상태 변경 기능을 제공한다. (`calculateTotal`, `complete`) |
| `IdGenerator` | Utility    | - 상품과 주문에 대한 고유 ID를 생성하고 관리한다.<br>- **싱글톤 패턴**을 사용해 프로그램 전체에서 단 하나의 인스턴스만 존재하도록 보장한다.              |

# 3. OOP 핵심 개념
## 1. 캡슐화
> "데이터는 보호하고, 기능은 공개한다."
* 적용
    * `Product`와 `Order` 클래스의 모든 필드(변수)는 `private`으로 선언되어 외부에서 직접 접근할 수 없다.
    * 데이터에 접근하거나 변경하려면 반드시 `public`으로 공개된 메서드 (`getter`/`setter`, `decreaseStock` 등)를 통해서만 가능하다.
* 중요한 점
    * 데이터 보호 : `product.price = -1000;`와 같이 잘못된 값으로 데이터가 오염되는 것을 막을 수 있다. (`setPrice` 메서드 안에서 유효성 검사를 하기 때문)
    * 유지보수 용이 : 나중에 재고 차감 방식이 변경되면 `decreaseStock` 메서드 내부만 수정하면 되기 때문에 해당 메서드를 사용하는 다른 코드에 영향을 주지 않는다.

## 2. 추상화
> "복잡한 내부 구현은 숨기고, 사용자에게는 단순한 기능만 보여준다."

* 적용
    * `ShopApp` 클래스는 `manager.processOrder(order);` 한 줄의 코드로 주문 처리를 요청한다.
    * `processOrder` 메서드 내부의 복잡한 과정(재고 확인, 금액 계산, 상태 변경 등)은 `ShopApp`이 전혀 알 필요가 없다.
* 중요한 점
    * 사용 편의성 : 메서드를 사용하는 입장에서 내부 로직을 몰라도 이름만 보고 쉽게 사용할 수 있다.
    * 역할 분리 : "주문 처리"라는 복잡한 과정의 책임이 `ShopManager`에게 위임되어 코드가 명확해진다.

## 3. 역할과 책임의 분리
> "각 클래스는 하나의 명확한 책임만 가져야 한다."

* 적용
    * `Product`는 상품 정보만, `Order`는 주문 정보만 책임진다.
    * `ShopManager`는 이 둘을 관리하는 책임만 진다.
    * 만약 `ShopApp`이 모든 일을 처리하면 `main` 메서드의 코드가 길어지고 유지보수가 어렵게 된다.
* 중요한 점
    * 모듈화 : 기능 단위로 코드가 분리되어 있어 특정 기능을 찾거나 수정하기 쉽다.
    * 팀 협업 : 여러 개발자가 각자 맡은 클래스만 집중해서 개발할 수 있기 때문에 효율적이다.

## 4. 객체 간의 협력
> "객체는 혼자 일하지 않는다. 다른 객체와 메시지를 주고 받으며 협력한다."

* 적용
    * `manager.addOrderItem(...)` 메서드
        * `ShopManager`는 `Product` 객체에게 `isAvailable()` 메시지를 보내 재고를 묻는다.
        * `Product`는 자신의 재고를 확인하고 `true` 또는 `false`로 응답한다.
        * `ShopManager`는 `Order` 객체에게 `addItem()` 메시지를 보내 상품 정보를 기록하라고 요청한다.
* 중요한 점
    * 실제 세상의 동작 방식을 코드로 자연스럽게 모델링할 수 있다.
    * 복잡한 기능을 여러 객체가 협력해 해결하므로 각 객체의 책임이 단순해진다.
